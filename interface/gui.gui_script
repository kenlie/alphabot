local abc = {"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"}
local alphabet_list = {}
local sorted_alphabet_list = {}
local abc_sequence = {}

function init(self)
    -- fetch the score text node for later use (assumes it is called "score")

    
    self.score_node = gui.get_node("score")
    
    self.left_node = gui.get_node("left_text")
    
    self.middle_node = gui.get_node("middle_text")
    
    self.right_node = gui.get_node("right_text")
    
    
    --self.left_node = gui.set_text(node, text)
    
    randomstring()
    tbl = alphabet_list
    sorted = sorted_alphabet_list
    
    print(tbl[1],tbl[2],tbl[3])
    print(sorted[1],sorted[2],sorted[3])
    
	self.left_node = gui.set_text(self.left_node, tbl[1])
	self.middle_node = gui.set_text(self.middle_node, tbl[2])
	self.right_node = gui.set_text(self.right_node, tbl[3])
	

    

    
    -- keep track of the current score counted up so far
    self.current_score = 30
    
    -- keep track of the target score we should count up to
    self.target_score = 0
    
    -- how fast we will update the score, in score/second
    self.score_update_speed = 1
	   
	   
	msg.post(".", "acquire_input_focus")
	
	

end

function update(self, dt)
	
    -- check if target score is more than current score
    if self.current_score > self.target_score then
        -- increment current score according to the speed
        self.current_score = self.current_score - dt * self.score_update_speed
        -- check if we went past the target score, clamp current score in that case
        if self.current_score <= self.target_score then
            self.current_score = self.target_score
        end
        -- update the score text node
        gui.set_text(self.score_node, "" .. math.floor(self.current_score))
    end
    

    
    
    
end

function randomstring(self)
	--Create random string ---
	
	math.randomseed(os.clock()*10000000000000000)	
	

	-- Flag tells if the table already contains char
	
	local flag = 1

	while table.getn(alphabet_list) < 3 do
	
		local s = abc[math.random(35)]
		
		for k in pairs (alphabet_list) do
			
			if s == alphabet_list[k] then 				
				print("already in table!")
				flag = 0
			end		
			
		end
		
		if (flag == 1) then
			table.insert(alphabet_list, s)
			table.insert(sorted_alphabet_list, s)
		end 
		
		table.sort(sorted_alphabet_list) 
		
		flag = 1		
	
		local s = abc[math.random(35)]
		
	end
	
	return alphabet_list, sorted_alphabet_list
	
end 

function delete_randomstring(self)

    for k in pairs (alphabet_list) do
    	alphabet_list[k] = nil
	end
	
end


function on_message(self, message_id, message, sender)
    -- check the message
    if message_id == hash("set_score") then
        self.target_score = message.score
    end
    
    -- TODO set new random alphabet to buttons on message--
    if message_id == hash("new_string") then
    
    	local s = abc[math.random(#abc)]
    	
    end
end

function on_input(self, action_id, action)
	if action_id == hash("mouse_press") and action.pressed then
		local x = action.x
		local y = action.y
		
		
	    local left_node = gui.get_node("left_text")
	    local middle_node = gui.get_node("middle_text")	    
	    local right_node = gui.get_node("right_text")
	    
	    if gui.pick_node(left_node, x, y) then
	    	
	    	a = gui.get_text(left_node)	    	
	    	table.insert(abc_sequence, a)  
	    	
	    	if compare_tables() then 	
	    		gui.set_enabled(left_node, false)
	    		
	    	elseif compare_tables() == false then
	    	
	    	    for k in pairs (abc_sequence) do
    				abc_sequence[k] = nil
				end
				gui.set_enabled(left_node, true)
				gui.set_enabled(middle_node, true)
				gui.set_enabled(right_node, true)
	    	end
	    		    	
	    	print("left")
	    	
	    elseif gui.pick_node(middle_node, x, y) then
	    
	    	b = gui.get_text(middle_node)	    	
	    	table.insert(abc_sequence, b)	
	    	print(abc_sequence[1]) 
	    	   	
	    	if compare_tables() then 	
	    		gui.set_enabled(middle_node, false)
	    	
	    	elseif compare_tables() == false then
	    	
	    	    for k in pairs (abc_sequence) do
    				abc_sequence[k] = nil
				end
				gui.set_enabled(left_node, true)
				gui.set_enabled(middle_node, true)
				gui.set_enabled(right_node, true)
				
	    	end
	    	
	    	print("middle")
	    	
	    elseif gui.pick_node(right_node, x, y) then
	    
	    	c = gui.get_text(right_node)	    	
	    	table.insert(abc_sequence, c)	
	    	    	
	    	if compare_tables() then 	
	    		gui.set_enabled(right_node, false)
	    		
	    	elseif compare_tables() == false then
	    	
	    	    for k in pairs (abc_sequence) do
    				abc_sequence[k] = nil
				end
				
				gui.set_enabled(left_node, true)
				gui.set_enabled(middle_node, true)
				gui.set_enabled(right_node, true)
				
	    	end
	    	
	    	print("right")
	    end
	end
end 

function compare_tables(self)
	for k in pairs (abc_sequence) do
		if abc_sequence[k] ~= sorted_alphabet_list[k] then
		print(k)
		return false 	
		end
	end
	
	return true
end 
	
		
	
	
	
	